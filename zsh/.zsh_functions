# ===========================
# PERFORMANCE: ZSH Functions (.zsh_functions)
# Optimized functions with better error handling and performance
# ===========================

# ===========================
# üì¶ EXTRACTORS - PERFORMANCE OPTIMIZED
# ===========================
# PERFORMANCE: Universal extract function with better error handling
extract() {
  # PERFORMANCE: Early exit if no argument provided
  [[ $# -eq 0 ]] && { echo "Usage: extract <file>"; return 1; }
  
  # PERFORMANCE: Check file exists before processing
  [[ ! -f "$1" ]] && { echo "Error: File '$1' not found"; return 1; }
  
  # PERFORMANCE: Use case statement for faster matching
  case "$1" in
    *.tar.bz2|*.tbz2) tar -xjf "$1" ;;
    *.tar.gz|*.tgz)   tar -xzf "$1" ;;
    *.tar.xz|*.txz)   tar -xJf "$1" ;;
    *.tar)            tar -xf "$1" ;;
    *.bz2)            bunzip2 "$1" ;;
    *.gz)             gunzip "$1" ;;
    *.zip)            unzip "$1" ;;
    *.rar)            unrar x "$1" ;;
    *.7z)             7z x "$1" ;;
    *.xz)             xz -d "$1" ;;
    *)                echo "Error: Unsupported format '$1'"; return 1 ;;
  esac
}

# ===========================
# üìÇ DIRECTORY MANAGEMENT - PERFORMANCE OPTIMIZED
# ===========================

# PERFORMANCE: Create directory and move into it with error handling
mkcd() {
  # PERFORMANCE: Early exit if no argument
  [[ $# -eq 0 ]] && { echo "Usage: mkcd <directory>"; return 1; }
  
  # PERFORMANCE: Create and change directory atomically
  mkdir -p "$1" && cd "$1" || {
    echo "Error: Failed to create or access directory '$1'"
    return 1
  }
}

# PERFORMANCE: Optimized function to go up N directory levels
up() {
  local levels=${1:-1}
  
  # PERFORMANCE: Validate input is a positive number
  [[ ! $levels =~ ^[0-9]+$ ]] && { echo "Usage: up [number]"; return 1; }
  
  # PERFORMANCE: Build path in one operation instead of loop
  local path=""
  for ((i=0; i<levels; i++)); do
    path="../$path"
  done
  
  # PERFORMANCE: Single cd operation
  cd "$path" || { echo "Error: Cannot go up $levels levels"; return 1; }
}

# ===========================
# üõ† SYSTEM UTILITIES - PERFORMANCE OPTIMIZED
# ===========================

# PERFORMANCE: Optimized disk usage with better formatting
diskusage() {
  # PERFORMANCE: Use more efficient du options and handle empty directories
  if [[ $(ls -A 2>/dev/null | wc -l) -eq 0 ]]; then
    echo "Directory is empty"
    return 0
  fi
  
  # PERFORMANCE: More efficient sorting and display
  du -sh * 2>/dev/null | sort -hr | head -20
}

# PERFORMANCE: Optimized file size finder with depth limit
biggestfiles() {
  local depth=${1:-3}  # Default depth of 3 for performance
  
  # PERFORMANCE: Limit search depth to avoid slow filesystem traversal
  find . -maxdepth "$depth" -type f -exec du -h {} + 2>/dev/null | \
    sort -rh | head -n 10
}

# PERFORMANCE: Safer process killing with confirmation
killproc() {
  [[ $# -eq 0 ]] && { echo "Usage: killproc <process_name>"; return 1; }
  
  local pids
  pids=$(pgrep -f "$1")
  
  if [[ -n "$pids" ]]; then
    echo "Found processes matching '$1':"
    ps -p "$pids" -o pid,comm,args 2>/dev/null
    
    # PERFORMANCE: Add confirmation for safety
    echo -n "Kill these processes? [y/N]: "
    read -r response
    if [[ "$response" =~ ^[Yy]$ ]]; then
      echo "$pids" | xargs -r kill -9
      echo "üî™ Killed process(es): $1"
    else
      echo "‚ùå Operation cancelled"
    fi
  else
    echo "‚ö†Ô∏è No process found matching: $1"
    return 1
  fi
}

# PERFORMANCE: Safer macOS cleanup with confirmation
cleanmac() {
  # PERFORMANCE: Check if running on macOS
  [[ "$(uname)" != "Darwin" ]] && { echo "This function is for macOS only"; return 1; }
  
  echo "‚ö†Ô∏è This will clean system caches. Continue? [y/N]: "
  read -r response
  
  if [[ "$response" =~ ^[Yy]$ ]]; then
    echo "üßπ Cleaning macOS caches..."
    
    # PERFORMANCE: Clean user caches safely
    [[ -d ~/Library/Caches ]] && find ~/Library/Caches -type f -delete 2>/dev/null
    [[ -d ~/Library/Logs ]] && find ~/Library/Logs -type f -delete 2>/dev/null
    
    # PERFORMANCE: Only clean system caches if user has sudo access
    if sudo -n true 2>/dev/null; then
      [[ -d /Library/Caches ]] && sudo find /Library/Caches -type f -delete 2>/dev/null
    else
      echo "Note: Skipping system caches (requires sudo)"
    fi
    
    echo "‚úÖ Cleanup complete!"
  else
    echo "‚ùå Cleanup cancelled"
  fi
}

# ===========================
# üåê NETWORK & INTERNET - PERFORMANCE OPTIMIZED
# ===========================

# PERFORMANCE: Enhanced website status checker
isup() {
  [[ $# -eq 0 ]] && { echo "Usage: isup <url>"; return 1; }
  
  local url="$1"
  # PERFORMANCE: Add protocol if missing
  [[ ! $url =~ ^https?:// ]] && url="https://$url"
  
  # PERFORMANCE: Use timeout and follow redirects
  local status
  status=$(curl -Is --connect-timeout 10 --max-time 30 "$url" 2>/dev/null | head -1)
  
  if [[ -n "$status" ]]; then
    echo "$url: $status"
  else
    echo "‚ùå $url: No response or unreachable"
    return 1
  fi
}

# PERFORMANCE: Enhanced ping test with better output
pingtest() {
  [[ $# -eq 0 ]] && { echo "Usage: pingtest <host>"; return 1; }
  
  echo "üèì Pinging $1..."
  ping -c 5 "$1" || {
    echo "‚ùå Failed to ping $1"
    return 1
  }
}

# PERFORMANCE: Enhanced DNS lookup with multiple servers
fastdns() {
  local target=${1:-google.com}
  
  echo "üîç DNS lookup for $target:"
  # PERFORMANCE: Test multiple DNS servers for speed comparison
  for server in 8.8.8.8 1.1.1.1 208.67.222.222; do
    echo -n "$server: "
    dig +short @"$server" "$target" 2>/dev/null | head -1 || echo "timeout"
  done
}

# ===========================
# üì¶ PACKAGE MANAGEMENT - PERFORMANCE OPTIMIZED
# ===========================

# PERFORMANCE: Enhanced Homebrew update with better feedback
brewupdate() {
  [[ "$(uname)" != "Darwin" ]] && { echo "Homebrew is for macOS only"; return 1; }
  
  echo "üç∫ Updating Homebrew..."
  brew update || { echo "‚ùå Update failed"; return 1; }
  
  echo "‚¨ÜÔ∏è Upgrading packages..."
  brew upgrade || { echo "‚ùå Upgrade failed"; return 1; }
  
  echo "üßπ Cleaning up..."
  brew cleanup || { echo "‚ùå Cleanup failed"; return 1; }
  
  echo "‚úÖ Homebrew update complete!"
}

# PERFORMANCE: Enhanced system update (cross-platform)
sysupdate() {
  case "$(uname)" in
    Darwin)
      brewupdate
      ;;
    Linux)
      # PERFORMANCE: Detect package manager automatically
      if command -v apt >/dev/null 2>&1; then
        echo "üì¶ Updating apt packages..."
        sudo apt update && sudo apt upgrade -y
      elif command -v pacman >/dev/null 2>&1; then
        echo "üì¶ Updating pacman packages..."
        sudo pacman -Syu
      elif command -v dnf >/dev/null 2>&1; then
        echo "üì¶ Updating dnf packages..."
        sudo dnf update -y
      else
        echo "‚ùå No supported package manager found"
        return 1
      fi
      ;;
    *)
      echo "‚ùå Unsupported operating system"
      return 1
      ;;
  esac
}

# ===========================
# üê≥ DOCKER HELPERS - PERFORMANCE OPTIMIZED
# ===========================

# PERFORMANCE: Enhanced Docker cleanup with safety checks
docker-clean() {
  # PERFORMANCE: Check Docker availability first
  if ! command -v docker >/dev/null 2>&1; then
    echo "‚ùå Docker not installed"
    return 1
  fi
  
  if ! docker info &>/dev/null; then
    echo "üê≥ Docker daemon not running"
    return 1
  fi
  
  # PERFORMANCE: Get stopped containers efficiently
  local stopped_containers
  stopped_containers=$(docker ps -aq --filter "status=exited")
  
  if [[ -n "$stopped_containers" ]]; then
    echo "üßπ Removing stopped containers..."
    docker rm $stopped_containers
    echo "‚úÖ Cleanup complete!"
  else
    echo "‚ú® No stopped containers to remove"
  fi
}

# PERFORMANCE: Enhanced Docker image cleanup with confirmation
docker-rmi() {
  if ! docker info &>/dev/null; then
    echo "üê≥ Docker daemon not running"
    return 1
  fi
  
  local images
  images=$(docker images -q)
  
  if [[ -n "$images" ]]; then
    echo "‚ö†Ô∏è This will remove ALL Docker images. Continue? [y/N]: "
    read -r response
    
    if [[ "$response" =~ ^[Yy]$ ]]; then
      echo "üóëÔ∏è Removing all images..."
      docker rmi $images
      echo "‚úÖ All images removed!"
    else
      echo "‚ùå Operation cancelled"
    fi
  else
    echo "‚ú® No images to remove"
  fi
}

# ===========================
# ‚è≥ TIME & PRODUCTIVITY - PERFORMANCE OPTIMIZED
# ===========================

# PERFORMANCE: Enhanced timer with better validation and display
timer() {
  [[ $# -eq 0 ]] && { echo "Usage: timer <seconds>"; return 1; }
  
  local seconds="$1"
  # PERFORMANCE: Validate input is a number
  [[ ! $seconds =~ ^[0-9]+$ ]] && { echo "Error: Please provide a number"; return 1; }
  
  echo "‚è±Ô∏è Timer set for $seconds seconds..."
  
  # PERFORMANCE: Show countdown if time is reasonable
  if [[ $seconds -le 60 ]]; then
    for ((i=seconds; i>0; i--)); do
      echo -ne "\r‚è∞ $i seconds remaining..."
      sleep 1
    done
    echo -ne "\rüéâ Time's up!                \n"
  else
    sleep "$seconds"
    echo "‚è∞ Timer finished after $seconds seconds!"
  fi
  
  # PERFORMANCE: System notification if available
  if command -v osascript >/dev/null 2>&1; then
    osascript -e 'display notification "Timer finished!" with title "Timer"' 2>/dev/null
  fi
}

# PERFORMANCE: Enhanced date/time display with timezone
now() {
  echo "üìÖ $(date '+%Y-%m-%d %H:%M:%S %Z')"
  echo "üåç UTC: $(date -u '+%Y-%m-%d %H:%M:%S')"
}

# ===========================
# üêô GITHUB HELPERS - PERFORMANCE OPTIMIZED
# ===========================

# PERFORMANCE: Enhanced GitHub repository opener with better error handling
ghopen() {
  # PERFORMANCE: Check if we're in a git repository first
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "‚ùå Not a Git repository"
    return 1
  fi
  
  # PERFORMANCE: Get remote URL more efficiently
  local url
  url=$(git remote get-url origin 2>/dev/null)
  
  if [[ -z "$url" ]]; then
    echo "‚ùå No 'origin' remote found"
    return 1
  fi
  
  # PERFORMANCE: Convert SSH to HTTPS URL more robustly
  case "$url" in
    git@github.com:*)
      url="https://github.com/${url#git@github.com:}"
      url="${url%.git}"
      ;;
    https://github.com/*)
      url="${url%.git}"
      ;;
    *)
      echo "‚ùå Not a GitHub repository"
      return 1
      ;;
  esac
  
  echo "üåê Opening: $url"
  
  # PERFORMANCE: Cross-platform browser opening
  case "$(uname)" in
    Darwin) open "$url" ;;
    Linux) xdg-open "$url" ;;
    *) echo "‚ùå Unsupported platform for browser opening" ;;
  esac
}

# PERFORMANCE: Quick git status with enhanced display
# Note: Renamed from 'gst' to avoid conflict with oh-my-zsh git plugin alias
gitst() {
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "‚ùå Not a Git repository"
    return 1
  fi
  
  echo "üìä Git Status:"
  git status --short --branch
}

# ===========================
# üöÄ PERFORMANCE UTILITIES
# ===========================

# PERFORMANCE: Function to benchmark shell startup time
benchmark-shell() {
  echo "‚è±Ô∏è Benchmarking shell startup time..."
  
  local total=0
  local runs=5
  
  for ((i=1; i<=runs; i++)); do
    echo -n "Run $i: "
    local time_output
    time_output=$(/usr/bin/time -p zsh -i -c 'exit' 2>&1 | grep real | awk '{print $2}')
    echo "${time_output}s"
    total=$(echo "$total + $time_output" | bc -l 2>/dev/null || echo "$total")
  done
  
  if command -v bc >/dev/null 2>&1; then
    local average
    average=$(echo "scale=3; $total / $runs" | bc -l)
    echo "üìä Average startup time: ${average}s"
  fi
}

# PERFORMANCE: Function to profile zsh startup
profile-zsh() {
  echo "üîç Profiling ZSH startup..."
  echo "This will show timing information for .zshrc loading"
  
  # Create a temporary profiling script
  local profile_script="/tmp/zsh_profile_$$"
  cat > "$profile_script" << 'EOF'
#!/bin/zsh
PS4=$'%D{%M%S%.} %N:%i> '
exec 3>&2 2>/tmp/zsh_profile.log
setopt xtrace prompt_subst
EOF
  
  echo "Run: zsh -c 'source $profile_script && source ~/.zshrc && exit'"
  echo "Then check: /tmp/zsh_profile.log"
}

# ===========================
# üëª GHOSTTY TERMINAL HELPERS - PERFORMANCE OPTIMIZED
# ===========================

# PERFORMANCE: Quick theme switching for Ghostty
ghostty-theme() {
  local theme="${1:-nord}"
  local config="$HOME/.config/ghostty/config"
  
  [[ ! -f "$config" ]] && { echo "‚ùå Ghostty config not found"; return 1; }
  
  # PERFORMANCE: Fast in-place theme switching
  if sed -i '' "s/^theme = .*/theme = $theme/" "$config" 2>/dev/null; then
    echo "üé® Ghostty theme changed to: $theme"
    
    # PERFORMANCE: Optional notification (macOS only)
    if command -v osascript >/dev/null 2>&1; then
      osascript -e "display notification \"Theme: $theme\" with title \"Ghostty\"" 2>/dev/null
    fi
  else
    echo "‚ùå Failed to change theme"
    return 1
  fi
}

# PERFORMANCE: Auto theme switching based on time of day
ghostty-auto-theme() {
  local hour=$(date +%H)
  local theme
  
  if [[ $hour -ge 20 || $hour -lt 8 ]]; then
    theme="nord"  # Dark theme for night
    echo "üåô Night mode: switching to $theme"
  else
    theme="solarized-light"  # Light theme for day
    echo "‚òÄÔ∏è Day mode: switching to $theme"
  fi
  
  ghostty-theme "$theme"
}

# PERFORMANCE: Sync Ghostty theme with system appearance (macOS)
ghostty-sync-system() {
  if ! command -v defaults >/dev/null 2>&1; then
    echo "‚ùå System appearance detection only works on macOS"
    return 1
  fi
  
  local appearance
  appearance=$(defaults read -g AppleInterfaceStyle 2>/dev/null || echo "Light")
  
  local theme
  if [[ "$appearance" == "Dark" ]]; then
    theme="nord"
  else
    theme="solarized-light"
  fi
  
  echo "üîÑ Syncing with system appearance: $appearance"
  ghostty-theme "$theme"
}

# PERFORMANCE: Quick Ghostty profile switching
ghostty-profile() {
  local profile="${1:-default}"
  local config="$HOME/.config/ghostty/config"
  local base_config="$HOME/.config/ghostty/config.base"
  
  case "$profile" in
    "coding")
      echo "üöÄ Switching to coding profile..."
      {
        echo "# Coding profile - optimized for development"
        echo "font-size = 12"
        echo "scrollback-limit = 5000"
        echo "background-opacity = 1.0"
        echo "cursor-style-blink = false"
        echo "bell = none"
        echo "theme = nord"
      } >> "$config"
      ;;
    "presentation") 
      echo "üìΩÔ∏è Switching to presentation profile..."
      {
        echo "# Presentation profile - high visibility"
        echo "font-size = 18"
        echo "background-opacity = 1.0"
        echo "theme = one-light"
        echo "cursor-style-blink = true"
        echo "window-decoration = false"
      } >> "$config"
      ;;
    "minimal")
      echo "‚ö° Switching to minimal profile..."
      {
        echo "# Minimal profile - maximum performance"
        echo "font-size = 12"
        echo "scrollback-limit = 1000"
        echo "background-opacity = 1.0"
        echo "background-blur-radius = 0"
        echo "image-support = false"
        echo "sixel = false"
      } >> "$config"
      ;;
    "default")
      echo "üîÑ Restoring default profile..."
      if [[ -f "$base_config" ]]; then
        cp "$base_config" "$config"
      else
        echo "‚ö†Ô∏è No base config found, keeping current settings"
      fi
      ;;
    *)
      echo "‚ùå Unknown profile: $profile"
      echo "Available profiles: coding, presentation, minimal, default"
      return 1
      ;;
  esac
  
  echo "‚úÖ Profile switched to: $profile"
}

# PERFORMANCE: Ghostty performance test
ghostty-benchmark() {
  echo "‚è±Ô∏è Benchmarking Ghostty performance..."
  
  # Test text rendering speed
  echo "üìù Testing text rendering..."
  time (for i in {1..1000}; do echo "Performance test line $i with various characters: Œ±Œ≤Œ≥Œ¥Œµ ‚Üê‚Üë‚Üí‚Üì ‚ñ≤‚ñº‚óÑ‚ñ∫ ‚ñ†‚ñ°‚óè‚óã"; done)
  
  # Test scrollback performance
  echo "üìú Testing scrollback performance..."
  time (seq 1 5000 | head -1000)
  
  echo "‚úÖ Benchmark complete!"
}

# ===========================
# üîß ZSH COMPLETION HELPERS - PERFORMANCE OPTIMIZED
# ===========================

# PERFORMANCE: Test completion behavior for debugging
test-completion() {
  local test_dir="${1:-.}"
  
  echo "üîç Testing completion in: $test_dir"
  echo "üìÅ All directories (including hidden):"
  
  # Show what would be completed
  print -l ${test_dir}/*(N-/)
  echo ""
  echo "üëª Hidden directories:"
  print -l ${test_dir}/.*(N-/)
  
  echo ""
  echo "üí° Completion settings:"
  [[ -o GLOB_DOTS ]] && echo "‚úÖ GLOB_DOTS enabled" || echo "‚ùå GLOB_DOTS disabled"
  [[ -o COMPLETE_IN_WORD ]] && echo "‚úÖ COMPLETE_IN_WORD enabled" || echo "‚ùå COMPLETE_IN_WORD disabled"
  [[ -o ALWAYS_TO_END ]] && echo "‚úÖ ALWAYS_TO_END enabled" || echo "‚ùå ALWAYS_TO_END disabled"
}

# PERFORMANCE: Reload completion system
reload-completions() {
  echo "üîÑ Reloading ZSH completion system..."
  
  # Remove old completion dump
  [[ -f ~/.zcompdump ]] && rm ~/.zcompdump
  
  # Reinitialize completion system
  autoload -Uz compinit
  compinit
  
  echo "‚úÖ Completion system reloaded!"
  echo "üí° Try: cd <TAB> to test hidden directory completion"
}

# PERFORMANCE: Test NVM lazy loading
test-nvm() {
  echo "üß™ Testing NVM Lazy Loading..."
  echo ""
  
  echo "üìä Current status:"
  echo "NVM loaded: $(if command -v nvm >/dev/null 2>&1 && [[ $(type nvm) != *"function"* ]]; then echo "‚úÖ Yes"; else echo "‚ùå No (lazy)"; fi)"
  echo "Node available: $(if command -v node >/dev/null 2>&1; then echo "‚úÖ Yes"; else echo "‚ùå No"; fi)"
  echo "NPM available: $(if command -v npm >/dev/null 2>&1; then echo "‚úÖ Yes"; else echo "‚ùå No"; fi)"
  echo ""
  
  echo "üöÄ Testing commands:"
  echo "Running 'node --version'..."
  node --version
  echo ""
  
  echo "Running 'npm --version'..."
  npm --version  
  echo ""
  
  echo "Running 'nvm --version'..."
  nvm --version
  echo ""
  
  echo "‚úÖ All NVM lazy loading tests passed!"
}

# ===========================
# üîç GIT-AWARE SEARCH FUNCTIONS - PERFORMANCE OPTIMIZED
# ===========================

# Search in git files only
fzg() {
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "‚ùå Not a Git repository"
    return 1
  fi
  
  git ls-files | fzf --preview 'bat --style=numbers --color=always {}' --bind 'ctrl-/:change-preview-window(down|hidden|)'
}

# Search git commits with preview
fzc() {
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "‚ùå Not a Git repository"
    return 1
  fi
  
  git log --oneline --color=always | fzf --ansi --preview 'git show --color=always {1}' --bind 'ctrl-/:change-preview-window(down|hidden|)'
}

# Search git branches with preview
fzb() {
  if ! git rev-parse --git-dir >/dev/null 2>&1; then
    echo "‚ùå Not a Git repository"
    return 1
  fi
  
  git branch -a --color=always | grep -v '/HEAD\s' | sort | fzf --ansi --preview 'git log --oneline --graph --date=short --color=always --pretty="format:%C(auto)%cd %h%d %s" $(sed s/^..// <<< {} | cut -d" " -f1) | head -20' --bind 'ctrl-/:change-preview-window(down|hidden|)'
}

# ===========================
# üîç TEXT SEARCH FUNCTIONS - PERFORMANCE OPTIMIZED
# ===========================

# Search text content interactively (usage: rgi "search_term")
rgi() {
  local search_term="${1:-}"
  if [[ -z "$search_term" ]]; then
    echo "Usage: rgi <search_term>"
    echo "Example: rgi \"TODO\" to search for TODO items"
    return 1
  fi
  rg --line-number --no-heading --smart-case "$search_term" . | fzf --preview "bat --color=always --style=numbers --highlight-line {2} {1}" --delimiter ":"
}

# Search files containing pattern with preview (usage: rgf "search_term")
rgf() {
  local search_term="${1:-}"
  if [[ -z "$search_term" ]]; then
    echo "Usage: rgf <search_term>"
    echo "Example: rgf \"function\" to find files containing 'function'"
    return 1
  fi
  rg --files-with-matches --no-messages "$search_term" | fzf --preview "rg '$search_term' {} --color=always --context 10" --preview-window 'right:60%'
}